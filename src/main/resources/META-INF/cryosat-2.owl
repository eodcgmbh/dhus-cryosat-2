<?xml version="1.0"?>
<!--
   Data Hub Service (DHuS) - For Space data distribution.
   Copyright (C) 2019 GAEL Systems

   This file is part of DHuS software sources.

   This program is free software: you can redistribute it and/or modify
   it under the terms of the GNU Affero General Public License as
   published by the Free Software Foundation, either version 3 of the
   License, or (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
   GNU Affero General Public License for more details.

   You should have received a copy of the GNU Affero General Public License
   along with this program. If not, see <http://www.gnu.org/licenses/>.
-->
<!DOCTYPE rdf:RDF [
   <!ENTITY rdf  "http://www.w3.org/1999/02/22-rdf-syntax-ns#">
   <!ENTITY rdfs "http://www.w3.org/2000/01/rdf-schema#">
   <!ENTITY owl  "http://www.w3.org/2002/07/owl#">
   <!ENTITY cryosat2 "http://www.esa.int/cryosat2#"> 
   <!ENTITY drb  "http://www.gael.fr/drb#">
   <!ENTITY dhus "http://www.gael.fr/dhus#">
   ]>

<rdf:RDF xmlns:owl  = "&owl;"
         xmlns:rdf  = "&rdf;"
         xmlns:rdfs = "&rdfs;"
         xmlns:cryosat2 = "&cryosat2;"
         xmlns:drb  = "&drb;"
         xmlns:dhus = "&dhus;"
         xml:base   = "&cryosat2;">

   <owl:Ontology rdf:about="&cryosat2;"/>

   <!-- CRYOSAT PRODUCT SIR_FDM_2_ -->
   <rdf:Description rdf:about="&cryosat2;productSIRFDM2">
      <dhus:metadataTypes rdf:parseType="Literal">
		  
         <!-- Indexed metadata -->
         
         <metadataType id="satellite"
                       name="Satellite"
                       contentType="text/plain"
                       category="summary">
         </metadataType>
         
         <metadataType id="instrument"
                       name="Instrument"
                       contentType="text/plain"
                       category="summary">
         </metadataType>
         
         <metadataType id="date"
                       name="Date"
                       contentType="text/date+iso8601"
                       category="summary">
         </metadataType>
         
         <!-- acquisition -->

         <metadataType id="beginPosition"
                       name="Sensing start"
                       contentType="text/date+iso8601"
                       category="product">
            <solrField name="beginposition"
                       type="tdate"/>
         </metadataType>

         <metadataType id="endPosition"
                       name="Sensing stop"
                       contentType="text/date+iso8601"
                       category="product">
            <solrField name="endposition"
                       type="tdate"/>
         </metadataType>
         
         <!-- footprint -->
         
         <metadataType id="GMLfootprint"
                       name="Footprint"
                       contentType="application/gml+xml"
                       category="product">
            <solrField name="gmlfootprint"
                       type="string"/>
         </metadataType>

         <metadataType id="footprint"
                       name="JTS footprint"
                       contentType="application/jts"
                       category="product">
            <solrField name="footprint"
                       type="location_rpt"/>
         </metadataType>
         
         <!-- platform -->

         <metadataType id="platformName"
                       name="Platform name"
                       contentType="text/plain"
                       category="platform">
            <solrField name="platformname"
                       type="text_general"/>
         </metadataType>

         <metadataType id="platformShortName"
                       name="Platform short name"
                       contentType="text/plain"
                       category="platform">
            <solrField name="platformshortname"
                       type="text_general"/>
         </metadataType>

         <metadataType id="platformSerialIdentifier"
                       name="Platform serial identifier"
                       contentType="text/plain"
                       category="platform">
            <solrField name="platformserialidentifier"
                       type="text_general"/>
         </metadataType>

         <metadataType id="platformNssdcIdentifier"
                       name="Platform NSSDC identifier"
                       contentType="text/plain"
                       category="platform">
            <solrField name="platformnssdcidentifier"
                       type="text_general"/>
         </metadataType>
         
         <!-- instrument -->

         <metadataType id="instrumentName"
                       name="Instrument name"
                       contentType="text/plain"
                       category="instrument">
            <solrField name="instrumentname"
                       type="text_general"/>
         </metadataType>

         <metadataType id="instrumentShortName"
                       name="Instrument short name"
                       contentType="text/plain"
                       category="instrument">
            <solrField name="instrumentshortname"
                       type="text_general"/>
         </metadataType>
         
         <!-- orbit -->

         <metadataType id="orbitNumber"
                       name="Orbit number"
                       contentType="text/integer"
                       category="product">
            <solrField name="orbitnumber"
                       type="int"/>
         </metadataType>

         <metadataType id="relativeOrbitNumber"
                       name="Relative orbit number"
                       contentType="text/integer"
                       category="product">
            <solrField name="relativeorbitnumber"
                       type="int"/>
         </metadataType>

         <metadataType id="cycle"
                       name="Cycle"
                       contentType="text/integer"
                       category="product">
            <solrField name="cycle"
                       type="int"/>
         </metadataType>

         <metadataType id="phase"
                       name="Phase"
                       contentType="text/integer"
                       category="product">
            <solrField name="phase"
                       type="int"/>
         </metadataType>
         
         <metadataType id="orbitDirection"
                       name="Orbit direction"
                       contentType="text/plain"
                       category="product">
            <solrField name="orbitdirection"
                       type="text_general"/>
         </metadataType>

         <!-- processing -->

         <metadataType id="processingLevel"
                       name="Processing level"
                       contentType="text/plain"
                       category="product">
            <solrField name="processinglevel"
                       type="text_general"/>
         </metadataType>

         <metadataType id="processorVersion"
                       name="Processor version"
                       contentType="text/plain"
                       category="product">
            <solrField name="processorversion"
                       type="text_general"/>
         </metadataType>

         <metadataType id="generationTime"
                       name="Generation time"
                       contentType="text/plain"
                       category="product">
         </metadataType>

         <metadataType id="processingMode"
                       name="Processing mode"
                       contentType="text/plain"
                       category="product">
            <solrField name="processingmode"
                       type="text_general"/>
         </metadataType>

         <metadataType id="processingModeAbbreviation"
                       name="Processing mode abbreviation"
                       contentType="text/plain"
                       category="product">
            <solrField name="processingmodeabbreviation"
                       type="text_general"/>
         </metadataType>
         
         <!-- other -->

         <metadataType id="productType"
                       name="Product type"
                       contentType="text/plain"
                       category="product">
            <solrField name="producttype"
                       type="text_general"/>
         </metadataType>

         <metadataType id="productDescription"
                       name="Product description"
                       contentType="text/plain"
                       category="product">
            <solrField name="productdescription"
                       type="text_general"/>
         </metadataType>

         <metadataType id="size"
                       name="Size"
                       contentType="text/plain"
                       category="summary">
            <solrField name="size"
                       type="string"/>
         </metadataType>
         
         <metadataType id="format"
                       name="Format"
                       contentType="text/plain"
                       category="product">
            <solrField name="format"
                       type="string"
                       required="true"/>
         </metadataType>
         
         <metadataType id="filename"
                       name="Filename"
                       contentType="text/plain"
                       category="summary">
            <solrField name="filename"
                       type="string"
                       required="true"/>
         </metadataType>
         
      </dhus:metadataTypes>
   </rdf:Description>

   <!-- CRYOSAT PRODUCT SIR_FDM_2_ -->
   <rdf:Description rdf:about="&cryosat2;productSIRFDM2">
      <dhus:support/>
      <dhus:identifier rdf:parseType="Literal">
      <![CDATA[
         fn:tokenize(name (.), '\.')[1]
      ]]>
      </dhus:identifier>

      <dhus:metadataExtractor  rdf:parseType="Literal">
      <![CDATA[
         <!-- ============================================================== -->
         <!-- FUNCTIONS                                                      -->
         <!-- ============================================================== -->

         declare function local:computeSizes ($path, $base as item()*) as item()*
         {
            let $product := .
            return
               fn:data($product/@size)
         };

         declare function local:roundHalfDown($arg, $precision) as xs:double*
         {
            xs:integer((xs:double($arg)*math:power(10, $precision))) div
               math:power(10, $precision)
         };

         declare function local:computedateTime ($inputDate as xs:string?) as xs:string
         {
            let $input := $inputDate
            return concat(substring($input, 5, 19),
                          ".000Z")
         };

		 declare function local:lon360to180($lon360 as xs:double?) as xs:double?
		 {
		 	let $lon180 := ($lon360 + 180) mod 360
	 		return ($lon180 - 180)
	 	 };        
	 	 
		 declare function local:addOffsetLat($lat as xs:double?,
		                                     $offset as xs:double?) as xs:double?
		 {
		 	let $lato := ($lat + $offset)
		 	return
		 	    if ($lato > 90)
		 	    then 90
		 	    else if ($lato < -90)
		 	    then -90
		 	    else $lato
	 	 };

	 	 declare function local:getIndices($count as xs:double?,
	 	                                   $reverse as xs:boolean?) as item()*
   		 {
		 let $step := (
					   if (xs:integer($count div 200) = 0)
				       then 1
					   else xs:integer($count div 200)
					  )
   		 let $indices1 := (
			for $index in (1 to $count) 
    			where $index mod $step = 0
    			return $index 
    			)
   		 let $indices2 := (
			for $index in (1 to $count) 
				let $i := xs:integer($count - $index + 1)
    			where $i mod $step = 0
    			return $i 
    			)
    	 return
    	     if ($count = 1)
    	     then (1,1)
    	     else if ($reverse)
    	     then ($count,$indices2,1)
    	     else (1,$indices1,$count)
   		 };	 	 

	 	 declare function local:getGmlFootprint($lats as item()*, 
	 	                                        $lons as item()*) as xs:string
   		 {
	   	 let $count := count($lats) 
		 return
			fn:string-join(
		 		(
				for $index in (1 to $count) 
				return 
				concat(local:truncateDecimal($lats[$index]),
					   ",",
					   local:truncateDecimal($lons[$index]))
				)," ")
   		 };
   		 
	 	 declare function local:getJtsFootprint($lats as item()*, 
	 	                                        $lons as item()*) as xs:string
   		 {
	   	 let $count := count($lats) 
		 return
		 concat(
            "POLYGON ((",
			fn:string-join(
		 		(
				for $index in (1 to $count) 
				return 
				concat(local:truncateDecimal($lons[$index]),
					   " ",
					   local:truncateDecimal($lats[$index]))
				),","),
			"))"
			)
   		 };   	  
   		                         
		 declare function local:truncateDecimal($input as xs:double?) as xs:string?
		 {
		    let $precision := 4
		    let $num := local:roundHalfDown($input, $precision)
			let $int := fn:tokenize(xs:string($num),'\.')[1]
			let $dec := fn:substring(fn:tokenize(xs:string($num),'\.')[2],1,$precision)
			return concat($int,".",$dec)
		 };	 	    

         <!-- ============================================================== -->
         <!-- VARIABLES                                                      -->
         <!-- ============================================================== -->

         let $name := name()

         let $identifier := fn:tokenize(name (.), '\.')[1]
         let $tarFile := ./*[name(.) = fn:concat( $identifier, ".tar") or name(.) = fn:concat( $identifier, ".TAR")]
         let $hdrFile := $tarFile/*[name(.) = fn:concat( $identifier, ".HDR")]
         let $dblFile := $tarFile/*[name(.) = fn:concat( $identifier, ".DBL")]

         let $VAR_Earth_Explorer_Header := $hdrFile/Earth_Explorer_Header

         let $VAR_Fixed_Header := $VAR_Earth_Explorer_Header/Fixed_Header

         let $VAR_Variable_Header := $VAR_Earth_Explorer_Header/Variable_Header

         let $VAR_beginPosition := local:computedateTime(
            data($VAR_Fixed_Header/Validity_Period/Validity_Start))

         let $VAR_endPosition := local:computedateTime(
            data($VAR_Fixed_Header/Validity_Period/Validity_Stop))
            
         let $product_type := fn:data($VAR_Fixed_Header/File_Type)

		 let $VAR_lat_scale := 1e-7
		 let $VAR_lon_scale := 1e-7
		 
         let $offset := 0.001         

		 let $count_all := fn:data( $dblFile/DSDS/DSD[1]/NUM_DSR )
		                  
		 let $lons1 := (
					    for $i in local:getIndices($count_all,xs:boolean("false"))
						    return
						    local:lon360to180( fn:data( $dblFile/RECORDS/RECORD[$i]/Longitude ) * $VAR_lon_scale )
					   )
					   
         let $count_final := fn:count($lons1)
         
         let $lons2 := (
                        for $index in (1 to $count_final) 
                            let $i := xs:integer($count_final - $index + 1)
                            return $lons1[$i] + $offset
                       )
         
		 let $lats1 := (
					    for $i in local:getIndices($count_all,xs:boolean("false"))
						    return
						    fn:data( $dblFile/RECORDS/RECORD[$i]/Latitude ) * $VAR_lat_scale 
					   )
         
         let $lats2 := (
                        for $index in (1 to $count_final) 
                            let $i := xs:integer($count_final - $index + 1)
                            return $lats1[$i]
                       )
         
         let $lats1mod := (
					    for $lat in $lats1
						    return 
						        if ( $lat > 85.05115 )
						        then 85.0511
						        else if ( $lat < -85.05115 )
						        then -85.0511
						        else $lat
					   )
		 let $lats2mod := (
					    for $lat in $lats2
						    return 
						        if ( $lat > 85.05115 )
						        then 85.0510
						        else if ( $lat < -85.05115 )
						        then -85.0510
						        else $lat
					   )
		 	  
		 let $lons := (
					   if ($count_final = 1)
				       then ( $lons1[1], $lons1[1], $lons1[1] + $offset, $lons1[1] + $offset, $lons1[1] )
					   else ( $lons1, $lons2, $lons1[1] )
					  )
		 let $lats := (
					   if ($count_final = 1)
				       then ( $lats1[1], $lats1[1] + $offset, $lats1[1] + $offset, $lats1[1], $lats1[1] )
					   else ( $lats1, $lats2, $lats1[1] )
					  )
		 let $latsmod := (
					   if ($count_final = 1)
				       then ( $lats1mod[1], $lats1mod[1] + $offset, $lats1mod[1] + $offset, $lats1mod[1], $lats1mod[1] )
					   else ( $lats1mod, $lats2mod, $lats1mod[1] )
					  )
		 
         let $extractions :=
         (

         <!-- ============================================================== -->
         <!-- EXTRACTIONS                                                    -->
         <!-- ============================================================== -->

         <!-- Indexed metadata -->

         <!-- SATELLITE -->
         <metadata name="Satellite"
                   category="summary" type="text/plain">
         Cryosat-2
         </metadata>,
         
         <!-- INSTRUMENT -->
         <metadata name="Instrument"
                   category="summary" type="text/plain">
         SIRAL
         </metadata>,
         
         <!-- DATE -->
         <metadata name="Date"
                   category="summary" type="text/date+iso8601">
         { $VAR_beginPosition }
         </metadata>,
         
         
         <!-- acquisition -->

         <!-- SENSING START -->
         <metadata queryable="beginposition" name="Sensing start"
                   category="product" type="text/date+iso8601">
         { $VAR_beginPosition }
         </metadata>,

         <!-- SENSING STOP -->
         <metadata queryable="endposition" name="Sensing stop"
                   category="product" type="text/date+iso8601">
         { $VAR_endPosition }
         </metadata>,

        
         <!-- platform -->

         <!-- PLATFORM NAME -->
         <metadata queryable="platformname" name="Platform name"
                   category="platform" type="text/plain">
         Cryosat
         </metadata>,

         <!-- PLATFORM SHORT NAME -->
         <metadata queryable="platformshortname" name="Platform short name"
                   category="platform" type="text/plain">
         Cryosat
         </metadata>,

         <!-- PLATFORM SERIAL IDENTIFIER -->
         <metadata queryable="platformserialidentifier" name="Platform serial identifier"
                   category="platform" type="text/plain">
         2
         </metadata>,

         <!-- PLATFORM NSSDC IDENTIFIER -->
         <metadata queryable="platformnssdcidentifier" name="Platform NSSDC identifier"
                   category="platform" type="text/plain">
         2010-013A
         </metadata>,


         <!-- instrument -->

         <!-- INSTRUMENT NAME -->
         <metadata queryable="instrumentname" name="Instrument name"
                   category="instrument" type="text/plain">
         SAR/Interferometric Radar Altimeter
         </metadata>,

         <!-- INSTRUMENT SHORT NAME -->
         <metadata queryable="instrumentshortname" name="Instrument short name"
                   category="instrument" type="text/plain">
         SIRAL
         </metadata>,


         <!-- orbit -->

         <!-- ORBIT NUMBER -->
         <metadata queryable="orbitnumber" name="Orbit number"
                   category="product" type="text/integer">
         { xs:integer(fn:data($VAR_Variable_Header/MPH/Abs_Orbit)) }
         </metadata>,

         <!-- RELATIVE ORBIT NUMBER -->
         <metadata queryable="relativeorbitnumber" name="Relative orbit number"
                   category="product" type="text/integer">
         { xs:integer(fn:data($VAR_Variable_Header/MPH/Rel_Orbit)) }
         </metadata>,

         <!-- CYCLE -->
         <metadata queryable="cycle" name="Cycle"
                   category="product" type="text/integer">
         { xs:integer(fn:data($VAR_Variable_Header/MPH/Cycle)) }
         </metadata>,

         <!-- PHASE -->
         <metadata queryable="phase" name="Phase"
                   category="product" type="text/integer">
         { xs:integer(fn:data($VAR_Variable_Header/MPH/Phase)) }
         </metadata>,

         <!-- ORBIT DIRECTION -->
         <metadata queryable="orbitdirection" name="Orbit direction"
                   category="product" type="text/plain">
         {
           let $VAR_Ascending_Flag :=
              fn:data($VAR_Variable_Header/SPH/Orbit_Information/Ascending_Flag)
           return
              if ($VAR_Ascending_Flag = "A")
              then "ASCENDING"
              else if ($VAR_Ascending_Flag = "D")
              then "DESCENDING"
              else "UNKNOWN"
         }
         </metadata>,
         

         <!-- processing -->

         <!-- PROCESSING LEVEL -->
<!--          
         {
            let $VAR_level := fn:substring($name, 17, 2)
            return
               if ($VAR_level = '2_' or $VAR_level = '_2')
               then "Level-2"
               else "UNKNOWN"
         }
-->         
         <metadata queryable="processinglevel" name="Processing level"
                   category="product" type="text/plain">
         Level-2
         </metadata>,

         <!-- PROCESSOR VERSION -->
         <metadata queryable="processorversion" name="Processor version"
                   category="product" type="text/plain">
         { fn:data($VAR_Fixed_Header/Source/Creator_Version) }
         </metadata>,

         <!-- GENERATION TIME -->
         <metadata name="Generation time"
                   category="product" type="text/plain">
         {
           local:computedateTime(
              fn:data($VAR_Fixed_Header/Source/Creation_Date))
         }
         </metadata>,

         <!-- PROCESSING MODE -->
         <metadata queryable="processingmode" name="Processing mode"
                   category="product" type="text/plain">
         { fn:data($VAR_Fixed_Header/File_Class) }
         </metadata>,

         <!-- PROCESSING MODE ABBREVIATION -->
         <metadata queryable="processingmodeabbreviation" name="Processing mode abbreviation"
                   category="product" type="text/plain">
         { fn:data($VAR_Variable_Header/MPH/Proc_Stage_Code) }
         </metadata>,
         
         
         <!-- other -->
         
         <!-- PRODUCT TYPE -->
         <metadata queryable="producttype" name="Product type"
                   category="product" type="text/plain">
         { $product_type  }
         </metadata>,

         <!-- PRODUCT DESCRIPTION -->
         <metadata queryable="productdescription" name="Product description"
                   category="product" type="text/plain">
         { fn:data($VAR_Fixed_Header/File_Description)  }
         </metadata>,

         <!-- SIZE -->
         <!-- WARN The input product is a zip, and so the
         result should be wrong -->
         <metadata queryable="size" name="Size"
                   category="summary" type="text/plain">
         {
            let $size := xs:double(fn:sum(local:computeSizes(., ())))
            let $kilo := 1024
            let $mega := xs:integer($kilo * 1024)
            let $giga := xs:integer($mega * 1024)
            let $tera := xs:integer($giga * 1024)
            let $kilo_size := local:roundHalfDown(($size div $kilo), 2)
            let $mega_size := local:roundHalfDown(($size div $mega), 2)
            let $giga_size := local:roundHalfDown(($size div $giga), 2)
            let $tera_size := local:roundHalfDown(($size div $tera), 2)
            return
               if ($size < 1024)
               then
                  concat ($size, " bytes")
               else
                  if (($size div $kilo) < 1024)
                  then
                     concat ($kilo_size, " KB")
                  else
                     if (($size div $mega) < 1024)
                        then
                           concat ($mega_size, " MB")
                     else
                        if (($size div $giga) < 1024)
                        then
                           concat ($giga_size, " GB")
                        else
                           concat ($tera_size, " TB")
         }
         </metadata>,
         
         <!-- FORMAT -->
         <metadata queryable="format" name="Format"
                   category="product" type="text/plain">
            Earth-Explorer
         </metadata>,
         
         <!-- FILENAME -->
         <metadata queryable="filename" name="Filename"
                   category="summary" type="text/plain">
         { $name }
         </metadata>

         )
         
         let $footprints :=
         (
         <!-- footprint -->
      
         <metadata
            queryable="GMLfootprint"
            category="product"
            name="Footprint"
            type="application/gml+xml">
            <gml:Polygon xmlns:gml="http://www.opengis.net/gml"
               srsName="http://www.opengis.net/gml/srs/epsg.xml#4326">
                <gml:outerBoundaryIs>
                  <gml:LinearRing>
                     <gml:coordinates>
                        {
                        local:getGmlFootprint($lats,$lons)
                        }
                     </gml:coordinates>
                  </gml:LinearRing>
               </gml:outerBoundaryIs>
            </gml:Polygon>
         </metadata>,
         
         <metadata
            queryable="footprint"
            category="product"
            name="JTS footprint"
            type="application/jts">
                        {
                        local:getJtsFootprint($latsmod,$lons)
                        }
         </metadata>
         )
         
         return
         (
         if (empty($lons))
         then $extractions
         else ($extractions,$footprints)
         )
      ]]>
      </dhus:metadataExtractor>

   </rdf:Description>



   <!-- CRYOSAT PRODUCT SIR L2 tar  -->
   <rdf:Description rdf:about="&cryosat2;productSIR2tar">
      <dhus:metadataTypes rdf:parseType="Literal">
		  
         <!-- Indexed metadata -->
         
         <metadataType id="satellite"
                       name="Satellite"
                       contentType="text/plain"
                       category="summary">
         </metadataType>
         
         <metadataType id="instrument"
                       name="Instrument"
                       contentType="text/plain"
                       category="summary">
         </metadataType>
         
         <metadataType id="date"
                       name="Date"
                       contentType="text/date+iso8601"
                       category="summary">
         </metadataType>
         
         <!-- acquisition -->

         <metadataType id="beginPosition"
                       name="Sensing start"
                       contentType="text/date+iso8601"
                       category="product">
            <solrField name="beginposition"
                       type="tdate"/>
         </metadataType>

         <metadataType id="endPosition"
                       name="Sensing stop"
                       contentType="text/date+iso8601"
                       category="product">
            <solrField name="endposition"
                       type="tdate"/>
         </metadataType>
         
         <!-- footprint -->
         
         <metadataType id="GMLfootprint"
                       name="Footprint"
                       contentType="application/gml+xml"
                       category="product">
            <solrField name="gmlfootprint"
                       type="string"/>
         </metadataType>

         <metadataType id="footprint"
                       name="JTS footprint"
                       contentType="application/jts"
                       category="product">
            <solrField name="footprint"
                       type="location_rpt"/>
         </metadataType>
         
         <!-- platform -->

         <metadataType id="platformName"
                       name="Platform name"
                       contentType="text/plain"
                       category="platform">
            <solrField name="platformname"
                       type="text_general"/>
         </metadataType>

         <metadataType id="platformShortName"
                       name="Platform short name"
                       contentType="text/plain"
                       category="platform">
            <solrField name="platformshortname"
                       type="text_general"/>
         </metadataType>

         <metadataType id="platformSerialIdentifier"
                       name="Platform serial identifier"
                       contentType="text/plain"
                       category="platform">
            <solrField name="platformserialidentifier"
                       type="text_general"/>
         </metadataType>

         <metadataType id="platformNssdcIdentifier"
                       name="Platform NSSDC identifier"
                       contentType="text/plain"
                       category="platform">
            <solrField name="platformnssdcidentifier"
                       type="text_general"/>
         </metadataType>
         
         <!-- instrument -->

         <metadataType id="instrumentName"
                       name="Instrument name"
                       contentType="text/plain"
                       category="instrument">
            <solrField name="instrumentname"
                       type="text_general"/>
         </metadataType>

         <metadataType id="instrumentShortName"
                       name="Instrument short name"
                       contentType="text/plain"
                       category="instrument">
            <solrField name="instrumentshortname"
                       type="text_general"/>
         </metadataType>
         
         <!-- orbit -->

         <metadataType id="orbitNumber"
                       name="Orbit number"
                       contentType="text/integer"
                       category="product">
            <solrField name="orbitnumber"
                       type="int"/>
         </metadataType>

         <metadataType id="relativeOrbitNumber"
                       name="Relative orbit number"
                       contentType="text/integer"
                       category="product">
            <solrField name="relativeorbitnumber"
                       type="int"/>
         </metadataType>

         <metadataType id="cycle"
                       name="Cycle"
                       contentType="text/integer"
                       category="product">
            <solrField name="cycle"
                       type="int"/>
         </metadataType>

         <metadataType id="phase"
                       name="Phase"
                       contentType="text/integer"
                       category="product">
            <solrField name="phase"
                       type="int"/>
         </metadataType>
         
         <metadataType id="orbitDirection"
                       name="Orbit direction"
                       contentType="text/plain"
                       category="product">
            <solrField name="orbitdirection"
                       type="text_general"/>
         </metadataType>

         <!-- processing -->

         <metadataType id="processingLevel"
                       name="Processing level"
                       contentType="text/plain"
                       category="product">
            <solrField name="processinglevel"
                       type="text_general"/>
         </metadataType>

         <metadataType id="processorVersion"
                       name="Processor version"
                       contentType="text/plain"
                       category="product">
            <solrField name="processorversion"
                       type="text_general"/>
         </metadataType>

         <metadataType id="generationTime"
                       name="Generation time"
                       contentType="text/plain"
                       category="product">
         </metadataType>

         <metadataType id="processingMode"
                       name="Processing mode"
                       contentType="text/plain"
                       category="product">
            <solrField name="processingmode"
                       type="text_general"/>
         </metadataType>

         <metadataType id="processingModeAbbreviation"
                       name="Processing mode abbreviation"
                       contentType="text/plain"
                       category="product">
            <solrField name="processingmodeabbreviation"
                       type="text_general"/>
         </metadataType>
         
         <!-- other -->

         <metadataType id="productType"
                       name="Product type"
                       contentType="text/plain"
                       category="product">
            <solrField name="producttype"
                       type="text_general"/>
         </metadataType>

         <metadataType id="productDescription"
                       name="Product description"
                       contentType="text/plain"
                       category="product">
            <solrField name="productdescription"
                       type="text_general"/>
         </metadataType>

         <metadataType id="size"
                       name="Size"
                       contentType="text/plain"
                       category="summary">
            <solrField name="size"
                       type="string"/>
         </metadataType>
         
         <metadataType id="format"
                       name="Format"
                       contentType="text/plain"
                       category="product">
            <solrField name="format"
                       type="string"
                       required="true"/>
         </metadataType>
         
         <metadataType id="filename"
                       name="Filename"
                       contentType="text/plain"
                       category="summary">
            <solrField name="filename"
                       type="string"
                       required="true"/>
         </metadataType>
         
      </dhus:metadataTypes>
   </rdf:Description>

   <!-- CRYOSAT PRODUCT SIR L2 tar -->
   <rdf:Description rdf:about="&cryosat2;productSIR2tar">
      <dhus:support/>
      <dhus:identifier rdf:parseType="Literal">
      <![CDATA[
         fn:tokenize(name (.), '\.')[1]
      ]]>
      </dhus:identifier>

      <dhus:metadataExtractor  rdf:parseType="Literal">
      <![CDATA[
         <!-- ============================================================== -->
         <!-- FUNCTIONS                                                      -->
         <!-- ============================================================== -->

         declare function local:computeSizes ($path, $base as item()*) as item()*
         {
            let $product := .
            return
               fn:data($product/@size)
         };

         declare function local:roundHalfDown($arg, $precision) as xs:double*
         {
            xs:integer((xs:double($arg)*math:power(10, $precision))) div
               math:power(10, $precision)
         };

         declare function local:computedateTime ($inputDate as xs:string?) as xs:string
         {
            let $input := $inputDate
            return concat(substring($input, 5, 19),
                          ".000Z")
         };

		 declare function local:lon360to180($lon360 as xs:double?) as xs:double?
		 {
		 	let $lon180 := ($lon360 + 180) mod 360
	 		return ($lon180 - 180)
	 	 };        
	 	 
		 declare function local:addOffsetLat($lat as xs:double?,
		                                     $offset as xs:double?) as xs:double?
		 {
		 	let $lato := ($lat + $offset)
		 	return
		 	    if ($lato > 90)
		 	    then 90
		 	    else if ($lato < -90)
		 	    then -90
		 	    else $lato
	 	 };

	 	 declare function local:getIndices($count as xs:double?,
	 	                                   $reverse as xs:boolean?) as item()*
   		 {
		 let $step := (
					   if (xs:integer($count div 200) = 0)
				       then 1
					   else xs:integer($count div 200)
					  )
   		 let $indices1 := (
			for $index in (1 to $count) 
    			where $index mod $step = 0
    			return $index 
    			)
   		 let $indices2 := (
			for $index in (1 to $count) 
				let $i := xs:integer($count - $index + 1)
    			where $i mod $step = 0
    			return $i 
    			)
    	 return
    	     if ($count = 1)
    	     then (1,1)
    	     else if ($reverse)
    	     then ($count,$indices2,1)
    	     else (1,$indices1,$count)
   		 };	 	 

	 	 declare function local:getGmlFootprint($lats as item()*, 
	 	                                        $lons as item()*) as xs:string
   		 {
	   	 let $count := count($lats) 
		 return
			fn:string-join(
		 		(
				for $index in (1 to $count) 
				return 
				concat(local:truncateDecimal($lats[$index]),
					   ",",
					   local:truncateDecimal($lons[$index]))
				)," ")
   		 };
   		 
	 	 declare function local:getJtsFootprint($lats as item()*, 
	 	                                        $lons as item()*) as xs:string
   		 {
	   	 let $count := count($lats) 
		 return
		 concat(
            "POLYGON ((",
			fn:string-join(
		 		(
				for $index in (1 to $count) 
				return 
				concat(local:truncateDecimal($lons[$index]),
					   " ",
					   local:truncateDecimal($lats[$index]))
				),","),
			"))"
			)
   		 };   	  
   		                         
		 declare function local:truncateDecimal($input as xs:double?) as xs:string?
		 {
		    let $precision := 4
		    let $num := local:roundHalfDown($input, $precision)
			let $int := fn:tokenize(xs:string($num),'\.')[1]
			let $dec := fn:substring(fn:tokenize(xs:string($num),'\.')[2],1,$precision)
			return concat($int,".",$dec)
		 };    

         <!-- ============================================================== -->
         <!-- VARIABLES                                                      -->
         <!-- ============================================================== -->

         let $name := name()

         let $identifier := fn:tokenize(name (.), '\.')[1]
         let $tarFile := ./*[name(.) = fn:concat( $identifier, ".tar") or name(.) = fn:concat( $identifier, ".TAR")]
         let $hdrFile := $tarFile/*[name(.) = fn:concat( $identifier, ".HDR")]
         let $ncFile := $tarFile/*[name(.) = fn:concat( $identifier, ".nc")]
         let $root := $ncFile/root

         let $VAR_Earth_Explorer_Header := $hdrFile/Earth_Explorer_Header

         let $VAR_Fixed_Header := $VAR_Earth_Explorer_Header/Fixed_Header

         let $VAR_Variable_Header := $VAR_Earth_Explorer_Header/Variable_Header

         let $VAR_beginPosition := local:computedateTime(
            data($VAR_Fixed_Header/Validity_Period/Validity_Start))

         let $VAR_endPosition := local:computedateTime(
            data($VAR_Fixed_Header/Validity_Period/Validity_Stop))
            
         let $product_type := fn:data($VAR_Fixed_Header/File_Type)

		 let $VAR_lat_scale := xs:float(fn:data($root/variables/lat_01/attributes/scale_factor))
		 let $VAR_lon_scale := xs:float(fn:data($root/variables/lon_01/attributes/scale_factor))
		 
		 let $axis_name := fn:data($root/variables/lon_01/axisName)
		 
		 let $count := fn:count(fn:data( $root/dataset/*[name(.) = $axis_name]/*[name(.) = $axis_name] ))
		 
         let $offset := 0.001

		 let $lons_all := fn:data( $root/dataset/lon_01/*[name(.) = $axis_name] )
		 let $lats_all := fn:data( $root/dataset/lat_01/*[name(.) = $axis_name] )
		 
		 let $lons1 := (
					    for $i in local:getIndices($count,xs:boolean("false"))
						    return local:lon360to180( $lons_all[$i] * $VAR_lon_scale )
					   )
		 let $lons2 := (
					    for $i in local:getIndices($count,xs:boolean("true"))
						    return local:lon360to180( $lons_all[$i] * $VAR_lon_scale + $offset )
					   )
		 let $lats1 := (
					    for $i in local:getIndices($count,xs:boolean("false"))
						    return $lats_all[$i] * $VAR_lat_scale 
					   )
		 let $lats2 := (
					    for $i in local:getIndices($count,xs:boolean("true"))
						    return $lats_all[$i] * $VAR_lat_scale
					   )
         let $lats1mod := (
					    for $i in local:getIndices($count,xs:boolean("false"))
					        let $lat := $lats_all[$i] * $VAR_lat_scale 
						    return 
						        if ( $lat > 85.05115 )
						        then 85.0511
						        else if ( $lat < -85.05115 )
						        then -85.0511
						        else $lat
					   )
		 let $lats2mod := (
					    for $i in local:getIndices($count,xs:boolean("true"))
					        let $lat := $lats_all[$i] * $VAR_lat_scale
						    return 
						        if ( $lat > 85.05115 )
						        then 85.0510
						        else if ( $lat < -85.05115 )
						        then -85.0510
						        else $lat
					   )
			  
		 let $lons := (
					   if ($count = 1)
				       then ( $lons1[1], $lons1[1], $lons1[1] + $offset, $lons1[1] + $offset, $lons1[1] )
					   else ( $lons1, $lons2, $lons1[1] )
					  )
		 let $lats := (
					   if ($count = 1)
				       then ( $lats1[1], $lats1[1] + $offset, $lats1[1] + $offset, $lats1[1], $lats1[1] )
					   else ( $lats1, $lats2, $lats1[1] )
					  )
		 let $latsmod := (
					   if ($count = 1)
				       then ( $lats1mod[1], $lats1mod[1] + $offset, $lats1mod[1] + $offset, $lats1mod[1], $lats1mod[1] )
					   else ( $lats1mod, $lats2mod, $lats1mod[1] )
					  )
		 
         let $extractions :=
         (

         <!-- ============================================================== -->
         <!-- EXTRACTIONS                                                    -->
         <!-- ============================================================== -->

         <!-- Indexed metadata -->

         <!-- SATELLITE -->
         <metadata name="Satellite"
                   category="summary" type="text/plain">
         Cryosat-2
         </metadata>,
         
         <!-- INSTRUMENT -->
         <metadata name="Instrument"
                   category="summary" type="text/plain">
         SIRAL
         </metadata>,
         
         <!-- DATE -->
         <metadata name="Date"
                   category="summary" type="text/date+iso8601">
         { $VAR_beginPosition }
         </metadata>,
         
         
         <!-- acquisition -->

         <!-- SENSING START -->
         <metadata queryable="beginposition" name="Sensing start"
                   category="product" type="text/date+iso8601">
         { $VAR_beginPosition }
         </metadata>,

         <!-- SENSING STOP -->
         <metadata queryable="endposition" name="Sensing stop"
                   category="product" type="text/date+iso8601">
         { $VAR_endPosition }
         </metadata>,

        
         <!-- platform -->

         <!-- PLATFORM NAME -->
         <metadata queryable="platformname" name="Platform name"
                   category="platform" type="text/plain">
         Cryosat
         </metadata>,

         <!-- PLATFORM SHORT NAME -->
         <metadata queryable="platformshortname" name="Platform short name"
                   category="platform" type="text/plain">
         Cryosat
         </metadata>,

         <!-- PLATFORM SERIAL IDENTIFIER -->
         <metadata queryable="platformserialidentifier" name="Platform serial identifier"
                   category="platform" type="text/plain">
         2
         </metadata>,

         <!-- PLATFORM NSSDC IDENTIFIER -->
         <metadata queryable="platformnssdcidentifier" name="Platform NSSDC identifier"
                   category="platform" type="text/plain">
         2010-013A
         </metadata>,


         <!-- instrument -->

         <!-- INSTRUMENT NAME -->
         <metadata queryable="instrumentname" name="Instrument name"
                   category="instrument" type="text/plain">
         SAR/Interferometric Radar Altimeter
         </metadata>,

         <!-- INSTRUMENT SHORT NAME -->
         <metadata queryable="instrumentshortname" name="Instrument short name"
                   category="instrument" type="text/plain">
         SIRAL
         </metadata>,


         <!-- orbit -->

         <!-- ORBIT NUMBER -->
         <metadata queryable="orbitnumber" name="Orbit number"
                   category="product" type="text/integer">
         { xs:integer(fn:data($VAR_Variable_Header/MPH/Abs_Orbit)) }
         </metadata>,

         <!-- RELATIVE ORBIT NUMBER -->
         <metadata queryable="relativeorbitnumber" name="Relative orbit number"
                   category="product" type="text/integer">
         { xs:integer(fn:data($VAR_Variable_Header/MPH/Rel_Orbit)) }
         </metadata>,

         <!-- CYCLE -->
         <metadata queryable="cycle" name="Cycle"
                   category="product" type="text/integer">
         { xs:integer(fn:data($VAR_Variable_Header/MPH/Cycle)) }
         </metadata>,

         <!-- PHASE -->
         <metadata queryable="phase" name="Phase"
                   category="product" type="text/integer">
         { xs:integer(fn:data($VAR_Variable_Header/MPH/Phase)) }
         </metadata>,

         <!-- ORBIT DIRECTION -->
         <metadata queryable="orbitdirection" name="Orbit direction"
                   category="product" type="text/plain">
         {
           let $VAR_Ascending_Flag :=
              fn:data($VAR_Variable_Header/SPH/Orbit_Information/Ascending_Flag)
           return
              if ($VAR_Ascending_Flag = "A")
              then "ASCENDING"
              else if ($VAR_Ascending_Flag = "D")
              then "DESCENDING"
              else "UNKNOWN"
         }
         </metadata>,
         

         <!-- processing -->

         <!-- PROCESSING LEVEL -->
<!--          
         {
            let $VAR_level := fn:substring($name, 17, 2)
            return
               if ($VAR_level = '2_' or $VAR_level = '_2')
               then "Level-2"
               else "UNKNOWN"
         }
-->         
         <metadata queryable="processinglevel" name="Processing level"
                   category="product" type="text/plain">
         Level-2
         </metadata>,

         <!-- PROCESSOR VERSION -->
         <metadata queryable="processorversion" name="Processor version"
                   category="product" type="text/plain">
         { fn:data($VAR_Fixed_Header/Source/Creator_Version) }
         </metadata>,

         <!-- GENERATION TIME -->
         <metadata name="Generation time"
                   category="product" type="text/plain">
         {
           local:computedateTime(
              fn:data($VAR_Fixed_Header/Source/Creation_Date))
         }
         </metadata>,

         <!-- PROCESSING MODE -->
         <metadata queryable="processingmode" name="Processing mode"
                   category="product" type="text/plain">
         { fn:data($VAR_Fixed_Header/File_Class) }
         </metadata>,

         <!-- PROCESSING MODE ABBREVIATION -->
         <metadata queryable="processingmodeabbreviation" name="Processing mode abbreviation"
                   category="product" type="text/plain">
         { fn:data($VAR_Variable_Header/MPH/Proc_Stage_Code) }
         </metadata>,
         
         
         <!-- other -->
         
         <!-- PRODUCT TYPE -->
         <metadata queryable="producttype" name="Product type"
                   category="product" type="text/plain">
         { $product_type  }
         </metadata>,

         <!-- PRODUCT DESCRIPTION -->
         <metadata queryable="productdescription" name="Product description"
                   category="product" type="text/plain">
         { fn:data($VAR_Fixed_Header/File_Description)  }
         </metadata>,

         <!-- SIZE -->
         <!-- WARN The input product is a zip, and so the
         result should be wrong -->
         <metadata queryable="size" name="Size"
                   category="summary" type="text/plain">
         {
            let $size := xs:double(fn:sum(local:computeSizes(., ())))
            let $kilo := 1024
            let $mega := xs:integer($kilo * 1024)
            let $giga := xs:integer($mega * 1024)
            let $tera := xs:integer($giga * 1024)
            let $kilo_size := local:roundHalfDown(($size div $kilo), 2)
            let $mega_size := local:roundHalfDown(($size div $mega), 2)
            let $giga_size := local:roundHalfDown(($size div $giga), 2)
            let $tera_size := local:roundHalfDown(($size div $tera), 2)
            return
               if ($size < 1024)
               then
                  concat ($size, " bytes")
               else
                  if (($size div $kilo) < 1024)
                  then
                     concat ($kilo_size, " KB")
                  else
                     if (($size div $mega) < 1024)
                        then
                           concat ($mega_size, " MB")
                     else
                        if (($size div $giga) < 1024)
                        then
                           concat ($giga_size, " GB")
                        else
                           concat ($tera_size, " TB")
         }
         </metadata>,
         
         <!-- FORMAT -->
         <metadata queryable="format" name="Format"
                   category="product" type="text/plain">
            Earth-Explorer
         </metadata>,
         
         <!-- FILENAME -->
         <metadata queryable="filename" name="Filename"
                   category="summary" type="text/plain">
         { $name }
         </metadata>

         )
         
         let $footprints :=
         (
         <!-- footprint -->
      
         <metadata
            queryable="GMLfootprint"
            category="product"
            name="Footprint"
            type="application/gml+xml">
            <gml:Polygon xmlns:gml="http://www.opengis.net/gml"
               srsName="http://www.opengis.net/gml/srs/epsg.xml#4326">
                <gml:outerBoundaryIs>
                  <gml:LinearRing>
                     <gml:coordinates>
                        {
                        local:getGmlFootprint($lats,$lons)
                        }
                     </gml:coordinates>
                  </gml:LinearRing>
               </gml:outerBoundaryIs>
            </gml:Polygon>
         </metadata>,
         
         <metadata
            queryable="footprint"
            category="product"
            name="JTS footprint"
            type="application/jts">
                        {
                        local:getJtsFootprint($latsmod,$lons)
                        }
         </metadata>
         )
         
         return
         (
         if (empty($lons))
         then $extractions
         else ($extractions,$footprints)
         )
      ]]>
      </dhus:metadataExtractor>

   </rdf:Description>



   <!-- CRYOSAT PRODUCT SIR L2 zip  -->
   <rdf:Description rdf:about="&cryosat2;productSIR2zip">
      <dhus:metadataTypes rdf:parseType="Literal">
		  
         <!-- Indexed metadata -->

         <metadataType id="satellite"
                       name="Satellite"
                       contentType="text/plain"
                       category="summary">
         </metadataType>
         
         <metadataType id="instrument"
                       name="Instrument"
                       contentType="text/plain"
                       category="summary">
         </metadataType>
         
         <metadataType id="date"
                       name="Date"
                       contentType="text/date+iso8601"
                       category="summary">
         </metadataType>
         
         <!-- acquisition -->

         <metadataType id="beginPosition"
                       name="Sensing start"
                       contentType="text/date+iso8601"
                       category="product">
            <solrField name="beginposition"
                       type="tdate"/>
         </metadataType>

         <metadataType id="endPosition"
                       name="Sensing stop"
                       contentType="text/date+iso8601"
                       category="product">
            <solrField name="endposition"
                       type="tdate"/>
         </metadataType>
         
         <!-- footprint -->
         
         <metadataType id="GMLfootprint"
                       name="Footprint"
                       contentType="application/gml+xml"
                       category="product">
            <solrField name="gmlfootprint"
                       type="string"/>
         </metadataType>

         <metadataType id="footprint"
                       name="JTS footprint"
                       contentType="application/jts"
                       category="product">
            <solrField name="footprint"
                       type="location_rpt"/>
         </metadataType>
         
         <!-- platform -->

         <metadataType id="platformName"
                       name="Platform name"
                       contentType="text/plain"
                       category="platform">
            <solrField name="platformname"
                       type="text_general"/>
         </metadataType>

         <metadataType id="platformShortName"
                       name="Platform short name"
                       contentType="text/plain"
                       category="platform">
            <solrField name="platformshortname"
                       type="text_general"/>
         </metadataType>

         <metadataType id="platformSerialIdentifier"
                       name="Platform serial identifier"
                       contentType="text/plain"
                       category="platform">
            <solrField name="platformserialidentifier"
                       type="text_general"/>
         </metadataType>

         <metadataType id="platformNssdcIdentifier"
                       name="Platform NSSDC identifier"
                       contentType="text/plain"
                       category="platform">
            <solrField name="platformnssdcidentifier"
                       type="text_general"/>
         </metadataType>
         
         <!-- instrument -->

         <metadataType id="instrumentName"
                       name="Instrument name"
                       contentType="text/plain"
                       category="instrument">
            <solrField name="instrumentname"
                       type="text_general"/>
         </metadataType>

         <metadataType id="instrumentShortName"
                       name="Instrument short name"
                       contentType="text/plain"
                       category="instrument">
            <solrField name="instrumentshortname"
                       type="text_general"/>
         </metadataType>
         
         <!-- orbit -->

         <metadataType id="orbitNumber"
                       name="Orbit number"
                       contentType="text/integer"
                       category="product">
            <solrField name="orbitnumber"
                       type="int"/>
         </metadataType>

         <metadataType id="relativeOrbitNumber"
                       name="Relative orbit number"
                       contentType="text/integer"
                       category="product">
            <solrField name="relativeorbitnumber"
                       type="int"/>
         </metadataType>

         <metadataType id="cycle"
                       name="Cycle"
                       contentType="text/integer"
                       category="product">
            <solrField name="cycle"
                       type="int"/>
         </metadataType>

         <metadataType id="phase"
                       name="Phase"
                       contentType="text/integer"
                       category="product">
            <solrField name="phase"
                       type="int"/>
         </metadataType>
         
         <metadataType id="orbitDirection"
                       name="Orbit direction"
                       contentType="text/plain"
                       category="product">
            <solrField name="orbitdirection"
                       type="text_general"/>
         </metadataType>

         <!-- processing -->

         <metadataType id="processingLevel"
                       name="Processing level"
                       contentType="text/plain"
                       category="product">
            <solrField name="processinglevel"
                       type="text_general"/>
         </metadataType>

         <metadataType id="processorVersion"
                       name="Processor version"
                       contentType="text/plain"
                       category="product">
            <solrField name="processorversion"
                       type="text_general"/>
         </metadataType>

         <metadataType id="generationTime"
                       name="Generation time"
                       contentType="text/plain"
                       category="product">
         </metadataType>

         <metadataType id="processingMode"
                       name="Processing mode"
                       contentType="text/plain"
                       category="product">
            <solrField name="processingmode"
                       type="text_general"/>
         </metadataType>

         <metadataType id="processingModeAbbreviation"
                       name="Processing mode abbreviation"
                       contentType="text/plain"
                       category="product">
            <solrField name="processingmodeabbreviation"
                       type="text_general"/>
         </metadataType>
         
         <!-- other -->

         <metadataType id="productType"
                       name="Product type"
                       contentType="text/plain"
                       category="product">
            <solrField name="producttype"
                       type="text_general"/>
         </metadataType>

         <metadataType id="productDescription"
                       name="Product description"
                       contentType="text/plain"
                       category="product">
            <solrField name="productdescription"
                       type="text_general"/>
         </metadataType>

         <metadataType id="size"
                       name="Size"
                       contentType="text/plain"
                       category="summary">
            <solrField name="size"
                       type="string"/>
         </metadataType>
         
         <metadataType id="format"
                       name="Format"
                       contentType="text/plain"
                       category="product">
            <solrField name="format"
                       type="string"
                       required="true"/>
         </metadataType>
         
         <metadataType id="filename"
                       name="Filename"
                       contentType="text/plain"
                       category="summary">
            <solrField name="filename"
                       type="string"
                       required="true"/>
         </metadataType>
         
      </dhus:metadataTypes>
   </rdf:Description>

   <!-- CRYOSAT PRODUCT SIR L2 zip -->
   <rdf:Description rdf:about="&cryosat2;productSIR2zip">
      <dhus:support/>
      <dhus:identifier rdf:parseType="Literal">
      <![CDATA[
         fn:tokenize(name (.), '\.')[1]
      ]]>
      </dhus:identifier>

      <dhus:metadataExtractor  rdf:parseType="Literal">
      <![CDATA[
         <!-- ============================================================== -->
         <!-- FUNCTIONS                                                      -->
         <!-- ============================================================== -->

         declare function local:computeSizes ($path, $base as item()*) as item()*
         {
            let $product := .
            return
               fn:data($product/@size)
         };

         declare function local:roundHalfDown($arg, $precision) as xs:double*
         {
            xs:integer((xs:double($arg)*math:power(10, $precision))) div
               math:power(10, $precision)
         };

         declare function local:computedateTime ($inputDate as xs:string?) as xs:string
         {
            let $input := $inputDate
            return concat(substring($input, 5, 19),
                          ".000Z")
         };

		 declare function local:lon360to180($lon360 as xs:double?) as xs:double?
		 {
		 	let $lon180 := ($lon360 + 180) mod 360
	 		return ($lon180 - 180)
	 	 };        
	 	 
		 declare function local:addOffsetLat($lat as xs:double?,
		                                     $offset as xs:double?) as xs:double?
		 {
		 	let $lato := ($lat + $offset)
		 	return
		 	    if ($lato > 90)
		 	    then 90
		 	    else if ($lato < -90)
		 	    then -90
		 	    else $lato
	 	 };

	 	 declare function local:getIndices($count as xs:double?,
	 	                                   $reverse as xs:boolean?) as item()*
   		 {
		 let $step := (
					   if (xs:integer($count div 150) = 0)
				       then 1
					   else xs:integer($count div 150)
					  )
   		 let $indices1 := (
			for $index in (1 to $count) 
    			where $index mod $step = 0
    			return $index 
    			)
   		 let $indices2 := (
			for $index in (1 to $count) 
				let $i := xs:integer($count - $index + 1)
    			where $i mod $step = 0
    			return $i 
    			)
    	 return
    	     if ($reverse)
    	     then ($count,$indices2,1)
    	     else (1,$indices1,$count)
   		 };	 	 

	 	 declare function local:getGmlFootprint($lats as item()*, 
	 	                                        $lons as item()*) as xs:string
   		 {
	   	 let $count := count($lats) 
		 return
			fn:string-join(
		 		(
				for $index in (1 to $count) 
				return 
				concat(local:truncateDecimal($lats[$index]),
					   ",",
					   local:truncateDecimal($lons[$index]))
				)," ")
   		 };
   		 
	 	 declare function local:getJtsFootprint($lats as item()*, 
	 	                                        $lons as item()*) as xs:string
   		 {
	   	 let $count := count($lats) 
		 return
		 concat(
            "POLYGON ((",
			fn:string-join(
		 		(
				for $index in (1 to $count) 
				return 
				concat(local:truncateDecimal($lons[$index]),
					   " ",
					   local:truncateDecimal($lats[$index]))
				),","),
			"))"
			)
   		 };   	  
   		                         
		 declare function local:truncateDecimal($input as xs:double?) as xs:string?
		 {
		    let $precision := 4
		    let $num := local:roundHalfDown($input, $precision)
			let $int := fn:tokenize(xs:string($num),'\.')[1]
			let $dec := fn:substring(fn:tokenize(xs:string($num),'\.')[2],1,$precision)
			return concat($int,".",$dec)
		 };	   
		               
		 declare function local:calculateTimeDelta($inputDate1 as xs:string?,
		 									       $inputDate2 as xs:string?) as xs:double?
		 {
		 let $year1  := fn:substring($inputDate1, 1, 4) 
		 let $month1 := fn:substring($inputDate1, 6, 2) 
		 let $day1   := fn:substring($inputDate1, 9, 2) 
		 let $hour1  := xs:double( fn:substring($inputDate1, 12, 2) ) 
		 let $min1   := xs:double( fn:substring($inputDate1, 15, 2) ) 
		 let $sec1   := xs:double( fn:substring($inputDate1, 18, 2) ) 
		 let $ymd1 := xs:double( fn:concat($year1,$month1,$day1) )
		 let $dectime1 := ( $sec1 + 
		                    $min1 * 60 +
		                    $hour1 * 3600 )
		                   
		 let $year2  := fn:substring($inputDate2, 1, 4) 
		 let $month2 := fn:substring($inputDate2, 6, 2) 
		 let $day2   := fn:substring($inputDate2, 9, 2) 
		 let $hour2  := xs:double( fn:substring($inputDate2, 12, 2) ) 
		 let $min2   := xs:double( fn:substring($inputDate2, 15, 2) ) 
		 let $sec2   := xs:double( fn:substring($inputDate2, 18, 2) ) 
		 let $ymd2 := xs:double( fn:concat($year2,$month2,$day2) )
		 let $dectime2 := ( $sec2 + 
		                    $min2 * 60 +
		                    $hour2 * 3600 )
		
		 let $timedelta := (
		    if ( $ymd1 = $ymd2 )
		    then ($dectime2 - $dectime1)
		    else if ( $ymd1 < $ymd2 )
		    then (86400 - $dectime1 + $dectime2)
		    else 0
		    )
		   
		 return $timedelta                    
		};	       

         <!-- ============================================================== -->
         <!-- VARIABLES                                                      -->
         <!-- ============================================================== -->

         let $name := name()

         let $identifier := fn:tokenize(name (.), '\.')[1]
         let $xmlFile :=  ./*[matches(name(.), ".*\.MD\.XML") or matches(name(.), ".*\.md\.xml")]        
         let $tarFile := ./*[matches(name(.), ".*\.tar") or matches(name(.), ".*\.TAR")]
         let $hdrFile := $tarFile/*[matches(name(.), ".*\.hdr") or matches(name(.), ".*\.HDR")]
         let $dblFile := $tarFile/*[matches(name(.), ".*\.dbl") or matches(name(.), ".*\.DBL")]
         
		 let $root := $dblFile/root	
		 
         let $VAR_Earth_Explorer_Header := $hdrFile/Earth_Explorer_Header

         let $VAR_Fixed_Header := $VAR_Earth_Explorer_Header/Fixed_Header

         let $VAR_Variable_Header := $VAR_Earth_Explorer_Header/Variable_Header

         let $VAR_beginPosition := local:computedateTime(
            data($VAR_Fixed_Header/Validity_Period/Validity_Start))

         let $VAR_endPosition := local:computedateTime(
            data($VAR_Fixed_Header/Validity_Period/Validity_Stop))

         let $product_type := fn:data($VAR_Fixed_Header/File_Type)
         let $processor_version := fn:data($VAR_Fixed_Header/Source/Creator_Version)
         let $baseline := fn:substring(fn:tokenize($identifier,'_')[last()],1,1)
         
         let $useNc := (
                        if ($product_type = "SIR_GDR_2_" and $baseline = "D")
                        then xs:boolean("true")
                        else if ($product_type = "SIR_LRM_2_" and $baseline = "D")
                        then xs:boolean("true")
                        else if ($product_type = "SIR_SAR_2_" and $baseline = "D")
                        then xs:boolean("true")
                        else if ($product_type = "SIR_SIN_2_" and $baseline = "D")
                        then xs:boolean("true")
                        else if ($product_type = "SIR_GOP_2_" and $baseline = "C")
                        then xs:boolean("true")
                        else if ($product_type = "SIR_GOPM_2" and $baseline = "C")
                        then xs:boolean("true")
                        else if ($product_type = "SIR_GOPN_2" and $baseline = "C")
                        then xs:boolean("true")
                        else if ($product_type = "SIR_GOPR_2" and $baseline = "C")
                        then xs:boolean("true")
                        else xs:boolean("false")
                       )
                       
		 let $VAR_lat_scale := (
		                        if ($useNc)
		                        then xs:float(fn:data($root/variables/lat_01/attributes/scale_factor))
		                        else 1e-7
		                       )
		 let $VAR_lon_scale := (
		                        if ($useNc)
		                        then xs:float(fn:data($root/variables/lon_01/attributes/scale_factor))
		                        else 1e-7
		                       )
         let $offset := 0.001
		 		 
		 let $axis_name := (
		                    if ($useNc)
		                    then fn:data($root/variables/lon_01/axisName)
		                    else ""
		                   )
		                   
		 let $count_all := (
		                if ($useNc)
		                then fn:data( $root/variables/lon_01/shape ) 
		                else fn:data( $dblFile/DSDS/DSD[1]/NUM_DSR )
		               )
		                  
		 let $lons1 := (
					    for $i in local:getIndices($count_all,xs:boolean("false"))
						    return
						    if ($useNc)
						    then local:lon360to180( fn:data( $root/dataset/lon_01/*[name(.) = $axis_name] )[$i] * $VAR_lon_scale )
						    else local:lon360to180( fn:data( $dblFile/RECORDS/RECORD[$i]/Longitude ) * $VAR_lon_scale )
					   )
					   
         let $count_final := fn:count($lons1)
         
         let $lons2 := (
                        for $index in (1 to $count_final) 
                            let $i := xs:integer($count_final - $index + 1)
                            return $lons1[$i] + $offset
                       )
         
		 let $lats1 := (
					    for $i in local:getIndices($count_all,xs:boolean("false"))
						    return
						    if ($useNc)
						    then fn:data( $root/dataset/lat_01/*[name(.) = $axis_name] )[$i] * $VAR_lat_scale 
						    else fn:data( $dblFile/RECORDS/RECORD[$i]/Latitude ) * $VAR_lat_scale 
					   )
         
         let $lats2 := (
                        for $index in (1 to $count_final) 
                            let $i := xs:integer($count_final - $index + 1)
                            return $lats1[$i]
                       )
         
         let $lats1mod := (
					    for $lat in $lats1
						    return 
						        if ( $lat > 85.05115 )
						        then 85.0511
						        else if ( $lat < -85.05115 )
						        then -85.0511
						        else $lat
					   )
		 let $lats2mod := (
					    for $lat in $lats2
						    return 
						        if ( $lat > 85.05115 )
						        then 85.0510
						        else if ( $lat < -85.05115 )
						        then -85.0510
						        else $lat
					   )
			  
		 let $lons := ( $lons1, $lons2, $lons1[1] )
		 let $lats := ( $lats1, $lats2, $lats1[1] )
		 let $latsmod := ( $lats1mod, $lats2mod, $lats1mod[1] )

         let $extractions :=
         (

         <!-- ============================================================== -->
         <!-- EXTRACTIONS                                                    -->
         <!-- ============================================================== -->

         <!-- Indexed metadata -->

         <!-- SATELLITE -->
         <metadata name="Satellite"
                   category="summary" type="text/plain">
         Cryosat-2
         </metadata>,
         
         <!-- INSTRUMENT -->
         <metadata name="Instrument"
                   category="summary" type="text/plain">
         SIRAL
         </metadata>,
         
         <!-- DATE -->
         <metadata name="Date"
                   category="summary" type="text/date+iso8601">
         { $VAR_beginPosition }
         </metadata>,
         
         
         <!-- acquisition -->

         <!-- SENSING START -->
         <metadata queryable="beginposition" name="Sensing start"
                   category="product" type="text/date+iso8601">
         { $VAR_beginPosition }
         </metadata>,

         <!-- SENSING STOP -->
         <metadata queryable="endposition" name="Sensing stop"
                   category="product" type="text/date+iso8601">
         { $VAR_endPosition }
         </metadata>,

        
         <!-- platform -->

         <!-- PLATFORM NAME -->
         <metadata queryable="platformname" name="Platform name"
                   category="platform" type="text/plain">
         Cryosat
         </metadata>,

         <!-- PLATFORM SHORT NAME -->
         <metadata queryable="platformshortname" name="Platform short name"
                   category="platform" type="text/plain">
         Cryosat
         </metadata>,

         <!-- PLATFORM SERIAL IDENTIFIER -->
         <metadata queryable="platformserialidentifier" name="Platform serial identifier"
                   category="platform" type="text/plain">
         2
         </metadata>,

         <!-- PLATFORM NSSDC IDENTIFIER -->
         <metadata queryable="platformnssdcidentifier" name="Platform NSSDC identifier"
                   category="platform" type="text/plain">
         2010-013A
         </metadata>,


         <!-- instrument -->

         <!-- INSTRUMENT NAME -->
         <metadata queryable="instrumentname" name="Instrument name"
                   category="instrument" type="text/plain">
         SAR/Interferometric Radar Altimeter
         </metadata>,

         <!-- INSTRUMENT SHORT NAME -->
         <metadata queryable="instrumentshortname" name="Instrument short name"
                   category="instrument" type="text/plain">
         SIRAL
         </metadata>,


         <!-- orbit -->

         <!-- ORBIT NUMBER -->
         <metadata queryable="orbitnumber" name="Orbit number"
                   category="product" type="text/integer">
         { xs:integer(fn:data($VAR_Variable_Header/MPH/Abs_Orbit)) }
         </metadata>,

         <!-- RELATIVE ORBIT NUMBER -->
         <metadata queryable="relativeorbitnumber" name="Relative orbit number"
                   category="product" type="text/integer">
         { xs:integer(fn:data($VAR_Variable_Header/MPH/Rel_Orbit)) }
         </metadata>,

         <!-- CYCLE -->
         <metadata queryable="cycle" name="Cycle"
                   category="product" type="text/integer">
         { xs:integer(fn:data($VAR_Variable_Header/MPH/Cycle)) }
         </metadata>,

         <!-- PHASE -->
         <metadata queryable="phase" name="Phase"
                   category="product" type="text/integer">
         { xs:integer(fn:data($VAR_Variable_Header/MPH/Phase)) }
         </metadata>,

         <!-- ORBIT DIRECTION -->
         <metadata queryable="orbitdirection" name="Orbit direction"
                   category="product" type="text/plain">
         {
           let $VAR_Ascending_Flag :=
              fn:data($VAR_Variable_Header/SPH/Orbit_Information/Ascending_Flag)
           return
              if ($VAR_Ascending_Flag = "A")
              then "ASCENDING"
              else if ($VAR_Ascending_Flag = "D")
              then "DESCENDING"
              else "UNKNOWN"
         }
         </metadata>,
         

         <!-- processing -->

         <!-- PROCESSING LEVEL -->
<!--          
         {
            let $VAR_level := fn:substring($name, 17, 2)
            return
               if ($VAR_level = '2_' or $VAR_level = '_2')
               then "Level-2"
               else "UNKNOWN"
         }
-->         
         <metadata queryable="processinglevel" name="Processing level"
                   category="product" type="text/plain">
         Level-2
         </metadata>,

         <!-- PROCESSOR VERSION -->
         <metadata queryable="processorversion" name="Processor version"
                   category="product" type="text/plain">
         { $processor_version }
         </metadata>,

         <!-- GENERATION TIME -->
         <metadata name="Generation time"
                   category="product" type="text/plain">
         {
           local:computedateTime(
              fn:data($VAR_Fixed_Header/Source/Creation_Date))
         }
         </metadata>,

         <!-- PROCESSING MODE -->
         <metadata queryable="processingmode" name="Processing mode"
                   category="product" type="text/plain">
         { fn:data($VAR_Fixed_Header/File_Class) }
         </metadata>,

         <!-- PROCESSING MODE ABBREVIATION -->
         <metadata queryable="processingmodeabbreviation" name="Processing mode abbreviation"
                   category="product" type="text/plain">
         { fn:data($VAR_Variable_Header/MPH/Proc_Stage_Code) }
         </metadata>,
         
         
         <!-- other -->
         
         <!-- PRODUCT TYPE -->
         <metadata queryable="producttype" name="Product type"
                   category="product" type="text/plain">
         { $product_type  }
         </metadata>,

         <!-- PRODUCT DESCRIPTION -->
         <metadata queryable="productdescription" name="Product description"
                   category="product" type="text/plain">
         { fn:data($VAR_Fixed_Header/File_Description)  }
         </metadata>,

         <!-- SIZE -->
         <!-- WARN The input product is a zip, and so the
         result should be wrong -->
         <metadata queryable="size" name="Size"
                   category="summary" type="text/plain">
         {
            let $size := xs:double(fn:sum(local:computeSizes(., ())))
            let $kilo := 1024
            let $mega := xs:integer($kilo * 1024)
            let $giga := xs:integer($mega * 1024)
            let $tera := xs:integer($giga * 1024)
            let $kilo_size := local:roundHalfDown(($size div $kilo), 2)
            let $mega_size := local:roundHalfDown(($size div $mega), 2)
            let $giga_size := local:roundHalfDown(($size div $giga), 2)
            let $tera_size := local:roundHalfDown(($size div $tera), 2)
            return
               if ($size < 1024)
               then
                  concat ($size, " bytes")
               else
                  if (($size div $kilo) < 1024)
                  then
                     concat ($kilo_size, " KB")
                  else
                     if (($size div $mega) < 1024)
                        then
                           concat ($mega_size, " MB")
                     else
                        if (($size div $giga) < 1024)
                        then
                           concat ($giga_size, " GB")
                        else
                           concat ($tera_size, " TB")
         }
         </metadata>,
         
         <!-- FORMAT -->
         <metadata queryable="format" name="Format"
                   category="product" type="text/plain">
            Earth-Explorer
         </metadata>,
         
         <!-- FILENAME -->
         <metadata queryable="filename" name="Filename"
                   category="summary" type="text/plain">
         { $name }
         </metadata>

         )
         
         let $footprints :=
         (
         <!-- footprint -->
      
         <metadata
            queryable="GMLfootprint"
            category="product"
            name="Footprint"
            type="application/gml+xml">
            <gml:Polygon xmlns:gml="http://www.opengis.net/gml"
               srsName="http://www.opengis.net/gml/srs/epsg.xml#4326">
                <gml:outerBoundaryIs>
                  <gml:LinearRing>
                     <gml:coordinates>
                        {
                        local:getGmlFootprint($lats,$lons)
                        }
                     </gml:coordinates>
                  </gml:LinearRing>
               </gml:outerBoundaryIs>
            </gml:Polygon>
         </metadata>,
         
         <metadata
            queryable="footprint"
            category="product"
            name="JTS footprint"
            type="application/jts">
                        {
                        local:getJtsFootprint($latsmod,$lons)
                        }
         </metadata>
         )
         
         return
         (
         if (empty($lons))
         then $extractions
         else ($extractions,$footprints)
         )
      ]]>
      </dhus:metadataExtractor>

   </rdf:Description>


</rdf:RDF>
